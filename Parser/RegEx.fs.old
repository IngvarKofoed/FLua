namespace Parser

open System

// http://www3.sympatico.ca/dbiggar/RE.home.html

module RegularExpression =

    type RegEx =
        | Char of value: char
        | Any 
        | Choise of left: RegEx * right: RegEx
        | Concatination of left: RegEx * right: RegEx
        | Group of exp: RegEx
        | Star of exp: RegEx
        | Plus of exp: RegEx
        | EOF
        | Fail of message: string


    type Context = {
        MetaChars: char list;
        ParseRegex: Context -> char list -> (RegEx * char list)
    }

    let parseEscapedChar context stream =
        printf "parseEscapedChar %A\n" stream
        match stream with 
        | [] -> (EOF, [])
        | x::xs -> 
            match x with 
            | c when List.contains c context.MetaChars -> (Char(c), xs)
            | c -> (Fail "meta char expected", stream)
        

    let parseChar context stream =
        printf "parseChar %A\n" stream
        match stream with
        | [] -> (EOF, [])
        | x::xs ->
            match x with
            | '\\' -> parseEscapedChar context xs 
            | c when List.contains c context.MetaChars -> (Fail "char expected", stream)
            | c -> (Char(x), xs)


    let parseGroup context stream = 
        printf "parseGroup %A\n" stream
        let (exp, rest) = context.ParseRegex context stream
        printf ">>parseGroup %A - %A\n" rest exp
        (Group(exp), rest)


    let parseElementary context stream =
        printf "parseElementary %A\n" stream
        match stream with
        | x::xs when x = '(' -> parseGroup context xs
        | x::xs when x = '.' -> (Any, xs)
        | _-> parseChar context stream 


    let parseBasic context stream = 
        printf "parseBasic %A\n" stream
        let (exp, rest) = parseElementary context stream
        printf ">>parseBasic %A - %A\n" rest exp
        match rest with
        | x::xs when x = '*' -> (Star(exp), xs)
        | x::xs when x = '+' -> (Plus(exp), xs)
        | _ -> (exp, rest)

    
    let rec parseSimple context stream =
        printf "parseSimple %A\n" stream
        let (exp, rest) = parseBasic context stream
        printf ">>parseSimple %A - %A\n" rest exp
        match rest with
        | [] -> (exp, rest)
        | x::xs ->
            match x with
            | '|' -> (exp, rest)
            | ')' -> (exp, rest)
            | _ ->
                let (exp', rest') = parseSimple context rest
                (Concatination(exp, exp'), rest')

        
    let rec parseRegex context stream =
        printf "parseRegex %A\n" stream
        let (exp, rest) = parseSimple context stream
        printf ">>parseRegex %A - %A\n" rest exp
        match rest with
        | [] -> (exp, rest)
        | x::xs -> 
            match x with 
            | '|' -> 
                let (exp', rest') = parseRegex context xs
                (Choise(exp, exp'), rest') 
            | ')' -> (exp, xs)
            | _ -> (exp, rest)


    let rec printRegex regex =
        match regex with
        | Char(v) -> printf "%c" v
        | Any -> printf "."
        | Choise(l, r) -> printRegex l; printf "|"; printRegex r
        | Concatination(l, r) -> printRegex l; printRegex r
        | Group(e) -> printf "("; printRegex e; printf ")"
        | Star(e) -> printRegex e; printf "*"
        | Plus(e) -> printRegex e; printf "+"
        | EOF -> printf "EOF"
        | Fail(m) -> printf "%s" m


    let context = { MetaChars = (List.ofSeq "|()*+"); ParseRegex = parseRegex }

    let parse stream = parseRegex context stream |> fst

    //let test = parseRegex context (List.ofSeq "(a)|(b)")
   // printRegex (fst test)

   // let test = parseRegex context (List.ofSeq "(a.|(b|g)*)*(cd|ef)*")

  //  printRegex (fst test)

   // let parseCharTestData = [
   //     ("a", (Char('a'), [])); 
   //     ("ab", (Char('a'), ['b'])); 
   //     ("\|a", (Char('|'), ['a']));
   //     ("|a", (Fail "char expected", ['|'; 'a']));
   //     ("\\a", (Fail "meta char expected", ['\\'; 'a']))
   //     ]


    //let parseTestRunner testData =
    //    testData
    //    |> List.map (fun data -> parseChar (List.ofSeq (fst data)) metaCharacter)